/**
 * Nnef_EventExposure
 * NEF Event Exposure Service. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.0.5
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "NetworkAreaInfo.h"

#include <sstream>

#include "Helpers.h"

namespace oai::nef::model {

NetworkAreaInfo::NetworkAreaInfo() {
  m_EcgisIsSet       = false;
  m_NcgisIsSet       = false;
  m_GRanNodeIdsIsSet = false;
  m_TaisIsSet        = false;
}

void NetworkAreaInfo::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::nef::helpers::ValidationException(msg.str());
  }
}

bool NetworkAreaInfo::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool NetworkAreaInfo::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "NetworkAreaInfo" : pathPrefix;

  if (ecgisIsSet()) {
    const std::vector<Ecgi>& value     = m_Ecgis;
    const std::string currentValuePath = _pathPrefix + ".ecgis";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const Ecgi& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".ecgis") && success;

        i++;
      }
    }
  }

  if (ncgisIsSet()) {
    const std::vector<Ncgi>& value     = m_Ncgis;
    const std::string currentValuePath = _pathPrefix + ".ncgis";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const Ncgi& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".ncgis") && success;

        i++;
      }
    }
  }

  if (gRanNodeIdsIsSet()) {
    const std::vector<GlobalRanNodeId>& value = m_GRanNodeIds;
    const std::string currentValuePath        = _pathPrefix + ".gRanNodeIds";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const GlobalRanNodeId& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success =
            value.validate(msg, currentValuePath + ".gRanNodeIds") && success;

        i++;
      }
    }
  }

  if (taisIsSet()) {
    const std::vector<Tai>& value      = m_Tais;
    const std::string currentValuePath = _pathPrefix + ".tais";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const Tai& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".tais") && success;

        i++;
      }
    }
  }

  return success;
}

bool NetworkAreaInfo::operator==(const NetworkAreaInfo& rhs) const {
  return

      ((!ecgisIsSet() && !rhs.ecgisIsSet()) ||
       (ecgisIsSet() && rhs.ecgisIsSet() && getEcgis() == rhs.getEcgis())) &&

      ((!ncgisIsSet() && !rhs.ncgisIsSet()) ||
       (ncgisIsSet() && rhs.ncgisIsSet() && getNcgis() == rhs.getNcgis())) &&

      ((!gRanNodeIdsIsSet() && !rhs.gRanNodeIdsIsSet()) ||
       (gRanNodeIdsIsSet() && rhs.gRanNodeIdsIsSet() &&
        getGRanNodeIds() == rhs.getGRanNodeIds())) &&

      ((!taisIsSet() && !rhs.taisIsSet()) ||
       (taisIsSet() && rhs.taisIsSet() && getTais() == rhs.getTais()))

          ;
}

bool NetworkAreaInfo::operator!=(const NetworkAreaInfo& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const NetworkAreaInfo& o) {
  j = nlohmann::json();
  if (o.ecgisIsSet() || !o.m_Ecgis.empty()) j["ecgis"] = o.m_Ecgis;
  if (o.ncgisIsSet() || !o.m_Ncgis.empty()) j["ncgis"] = o.m_Ncgis;
  if (o.gRanNodeIdsIsSet() || !o.m_GRanNodeIds.empty())
    j["gRanNodeIds"] = o.m_GRanNodeIds;
  if (o.taisIsSet() || !o.m_Tais.empty()) j["tais"] = o.m_Tais;
}

void from_json(const nlohmann::json& j, NetworkAreaInfo& o) {
  if (j.find("ecgis") != j.end()) {
    j.at("ecgis").get_to(o.m_Ecgis);
    o.m_EcgisIsSet = true;
  }
  if (j.find("ncgis") != j.end()) {
    j.at("ncgis").get_to(o.m_Ncgis);
    o.m_NcgisIsSet = true;
  }
  if (j.find("gRanNodeIds") != j.end()) {
    j.at("gRanNodeIds").get_to(o.m_GRanNodeIds);
    o.m_GRanNodeIdsIsSet = true;
  }
  if (j.find("tais") != j.end()) {
    j.at("tais").get_to(o.m_Tais);
    o.m_TaisIsSet = true;
  }
}

std::vector<Ecgi> NetworkAreaInfo::getEcgis() const {
  return m_Ecgis;
}
void NetworkAreaInfo::setEcgis(std::vector<Ecgi> const& value) {
  m_Ecgis      = value;
  m_EcgisIsSet = true;
}
bool NetworkAreaInfo::ecgisIsSet() const {
  return m_EcgisIsSet;
}
void NetworkAreaInfo::unsetEcgis() {
  m_EcgisIsSet = false;
}
std::vector<Ncgi> NetworkAreaInfo::getNcgis() const {
  return m_Ncgis;
}
void NetworkAreaInfo::setNcgis(std::vector<Ncgi> const& value) {
  m_Ncgis      = value;
  m_NcgisIsSet = true;
}
bool NetworkAreaInfo::ncgisIsSet() const {
  return m_NcgisIsSet;
}
void NetworkAreaInfo::unsetNcgis() {
  m_NcgisIsSet = false;
}
std::vector<GlobalRanNodeId> NetworkAreaInfo::getGRanNodeIds() const {
  return m_GRanNodeIds;
}
void NetworkAreaInfo::setGRanNodeIds(
    std::vector<GlobalRanNodeId> const& value) {
  m_GRanNodeIds      = value;
  m_GRanNodeIdsIsSet = true;
}
bool NetworkAreaInfo::gRanNodeIdsIsSet() const {
  return m_GRanNodeIdsIsSet;
}
void NetworkAreaInfo::unsetGRanNodeIds() {
  m_GRanNodeIdsIsSet = false;
}
std::vector<Tai> NetworkAreaInfo::getTais() const {
  return m_Tais;
}
void NetworkAreaInfo::setTais(std::vector<Tai> const& value) {
  m_Tais      = value;
  m_TaisIsSet = true;
}
bool NetworkAreaInfo::taisIsSet() const {
  return m_TaisIsSet;
}
void NetworkAreaInfo::unsetTais() {
  m_TaisIsSet = false;
}

}  // namespace oai::nef::model
