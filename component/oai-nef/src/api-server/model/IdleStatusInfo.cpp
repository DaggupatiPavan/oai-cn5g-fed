/**
 * 3gpp-monitoring-event
 * API for Monitoring Event. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "IdleStatusInfo.h"

#include <sstream>

#include "Helpers.h"

namespace oai::nef::model {

IdleStatusInfo::IdleStatusInfo() {
  m_ActiveTime                      = 0;
  m_ActiveTimeIsSet                 = false;
  m_EdrxCycleLength                 = 0.0f;
  m_EdrxCycleLengthIsSet            = false;
  m_SuggestedNumberOfDlPackets      = 0;
  m_SuggestedNumberOfDlPacketsIsSet = false;
  m_IdleStatusTimestamp             = "";
  m_IdleStatusTimestampIsSet        = false;
  m_PeriodicAUTimer                 = 0;
  m_PeriodicAUTimerIsSet            = false;
}

void IdleStatusInfo::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::nef::helpers::ValidationException(msg.str());
  }
}

bool IdleStatusInfo::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool IdleStatusInfo::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "IdleStatusInfo" : pathPrefix;

  if (activeTimeIsSet()) {
    const int32_t& value               = m_ActiveTime;
    const std::string currentValuePath = _pathPrefix + ".activeTime";

    if (value < 0) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  if (edrxCycleLengthIsSet()) {
    const float& value                 = m_EdrxCycleLength;
    const std::string currentValuePath = _pathPrefix + ".edrxCycleLength";

    if (value < static_cast<float>(0)) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  if (suggestedNumberOfDlPacketsIsSet()) {
    const int32_t& value = m_SuggestedNumberOfDlPackets;
    const std::string currentValuePath =
        _pathPrefix + ".suggestedNumberOfDlPackets";

    if (value < 0) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  if (periodicAUTimerIsSet()) {
    const int32_t& value               = m_PeriodicAUTimer;
    const std::string currentValuePath = _pathPrefix + ".periodicAUTimer";

    if (value < 0) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  return success;
}

bool IdleStatusInfo::operator==(const IdleStatusInfo& rhs) const {
  return

      ((!activeTimeIsSet() && !rhs.activeTimeIsSet()) ||
       (activeTimeIsSet() && rhs.activeTimeIsSet() &&
        getActiveTime() == rhs.getActiveTime())) &&

      ((!edrxCycleLengthIsSet() && !rhs.edrxCycleLengthIsSet()) ||
       (edrxCycleLengthIsSet() && rhs.edrxCycleLengthIsSet() &&
        getEdrxCycleLength() == rhs.getEdrxCycleLength())) &&

      ((!suggestedNumberOfDlPacketsIsSet() &&
        !rhs.suggestedNumberOfDlPacketsIsSet()) ||
       (suggestedNumberOfDlPacketsIsSet() &&
        rhs.suggestedNumberOfDlPacketsIsSet() &&
        getSuggestedNumberOfDlPackets() ==
            rhs.getSuggestedNumberOfDlPackets())) &&

      ((!idleStatusTimestampIsSet() && !rhs.idleStatusTimestampIsSet()) ||
       (idleStatusTimestampIsSet() && rhs.idleStatusTimestampIsSet() &&
        getIdleStatusTimestamp() == rhs.getIdleStatusTimestamp())) &&

      ((!periodicAUTimerIsSet() && !rhs.periodicAUTimerIsSet()) ||
       (periodicAUTimerIsSet() && rhs.periodicAUTimerIsSet() &&
        getPeriodicAUTimer() == rhs.getPeriodicAUTimer()))

          ;
}

bool IdleStatusInfo::operator!=(const IdleStatusInfo& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const IdleStatusInfo& o) {
  j = nlohmann::json();
  if (o.activeTimeIsSet()) j["activeTime"] = o.m_ActiveTime;
  if (o.edrxCycleLengthIsSet()) j["edrxCycleLength"] = o.m_EdrxCycleLength;
  if (o.suggestedNumberOfDlPacketsIsSet())
    j["suggestedNumberOfDlPackets"] = o.m_SuggestedNumberOfDlPackets;
  if (o.idleStatusTimestampIsSet())
    j["idleStatusTimestamp"] = o.m_IdleStatusTimestamp;
  if (o.periodicAUTimerIsSet()) j["periodicAUTimer"] = o.m_PeriodicAUTimer;
}

void from_json(const nlohmann::json& j, IdleStatusInfo& o) {
  if (j.find("activeTime") != j.end()) {
    j.at("activeTime").get_to(o.m_ActiveTime);
    o.m_ActiveTimeIsSet = true;
  }
  if (j.find("edrxCycleLength") != j.end()) {
    j.at("edrxCycleLength").get_to(o.m_EdrxCycleLength);
    o.m_EdrxCycleLengthIsSet = true;
  }
  if (j.find("suggestedNumberOfDlPackets") != j.end()) {
    j.at("suggestedNumberOfDlPackets").get_to(o.m_SuggestedNumberOfDlPackets);
    o.m_SuggestedNumberOfDlPacketsIsSet = true;
  }
  if (j.find("idleStatusTimestamp") != j.end()) {
    j.at("idleStatusTimestamp").get_to(o.m_IdleStatusTimestamp);
    o.m_IdleStatusTimestampIsSet = true;
  }
  if (j.find("periodicAUTimer") != j.end()) {
    j.at("periodicAUTimer").get_to(o.m_PeriodicAUTimer);
    o.m_PeriodicAUTimerIsSet = true;
  }
}

int32_t IdleStatusInfo::getActiveTime() const {
  return m_ActiveTime;
}
void IdleStatusInfo::setActiveTime(int32_t const value) {
  m_ActiveTime      = value;
  m_ActiveTimeIsSet = true;
}
bool IdleStatusInfo::activeTimeIsSet() const {
  return m_ActiveTimeIsSet;
}
void IdleStatusInfo::unsetActiveTime() {
  m_ActiveTimeIsSet = false;
}
float IdleStatusInfo::getEdrxCycleLength() const {
  return m_EdrxCycleLength;
}
void IdleStatusInfo::setEdrxCycleLength(float const value) {
  m_EdrxCycleLength      = value;
  m_EdrxCycleLengthIsSet = true;
}
bool IdleStatusInfo::edrxCycleLengthIsSet() const {
  return m_EdrxCycleLengthIsSet;
}
void IdleStatusInfo::unsetEdrxCycleLength() {
  m_EdrxCycleLengthIsSet = false;
}
int32_t IdleStatusInfo::getSuggestedNumberOfDlPackets() const {
  return m_SuggestedNumberOfDlPackets;
}
void IdleStatusInfo::setSuggestedNumberOfDlPackets(int32_t const value) {
  m_SuggestedNumberOfDlPackets      = value;
  m_SuggestedNumberOfDlPacketsIsSet = true;
}
bool IdleStatusInfo::suggestedNumberOfDlPacketsIsSet() const {
  return m_SuggestedNumberOfDlPacketsIsSet;
}
void IdleStatusInfo::unsetSuggestedNumberOfDlPackets() {
  m_SuggestedNumberOfDlPacketsIsSet = false;
}
std::string IdleStatusInfo::getIdleStatusTimestamp() const {
  return m_IdleStatusTimestamp;
}
void IdleStatusInfo::setIdleStatusTimestamp(std::string const& value) {
  m_IdleStatusTimestamp      = value;
  m_IdleStatusTimestampIsSet = true;
}
bool IdleStatusInfo::idleStatusTimestampIsSet() const {
  return m_IdleStatusTimestampIsSet;
}
void IdleStatusInfo::unsetIdleStatusTimestamp() {
  m_IdleStatusTimestampIsSet = false;
}
int32_t IdleStatusInfo::getPeriodicAUTimer() const {
  return m_PeriodicAUTimer;
}
void IdleStatusInfo::setPeriodicAUTimer(int32_t const value) {
  m_PeriodicAUTimer      = value;
  m_PeriodicAUTimerIsSet = true;
}
bool IdleStatusInfo::periodicAUTimerIsSet() const {
  return m_PeriodicAUTimerIsSet;
}
void IdleStatusInfo::unsetPeriodicAUTimer() {
  m_PeriodicAUTimerIsSet = false;
}

}  // namespace oai::nef::model
