/**
 * 3gpp-traffic-influence
 * API for AF traffic influence Â© 2021, 3GPP Organizational Partners (ARIB,
 * ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "TrafficInfluSubPatch.h"

#include <sstream>

#include "Helpers.h"

namespace oai::nef::model {

TrafficInfluSubPatch::TrafficInfluSubPatch() {
  m_AppReloInd             = false;
  m_AppReloIndIsSet        = false;
  m_TrafficFiltersIsSet    = false;
  m_EthTrafficFiltersIsSet = false;
  m_TrafficRoutesIsSet     = false;
  m_TfcCorrInd             = false;
  m_TfcCorrIndIsSet        = false;
  m_TempValiditiesIsSet    = false;
  m_ValidGeoZoneIdsIsSet   = false;
  m_AfAckInd               = false;
  m_AfAckIndIsSet          = false;
  m_AddrPreserInd          = false;
  m_AddrPreserIndIsSet     = false;
}

void TrafficInfluSubPatch::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::nef::helpers::ValidationException(msg.str());
  }
}

bool TrafficInfluSubPatch::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool TrafficInfluSubPatch::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "TrafficInfluSubPatch" : pathPrefix;

  if (trafficFiltersIsSet()) {
    const std::vector<FlowInfo>& value = m_TrafficFilters;
    const std::string currentValuePath = _pathPrefix + ".trafficFilters";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const FlowInfo& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".trafficFilters") &&
                  success;

        i++;
      }
    }
  }

  if (ethTrafficFiltersIsSet()) {
    const std::vector<EthFlowDescription>& value = m_EthTrafficFilters;
    const std::string currentValuePath = _pathPrefix + ".ethTrafficFilters";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const EthFlowDescription& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success =
            value.validate(msg, currentValuePath + ".ethTrafficFilters") &&
            success;

        i++;
      }
    }
  }

  if (trafficRoutesIsSet()) {
    const std::vector<RouteToLocation>& value = m_TrafficRoutes;
    const std::string currentValuePath        = _pathPrefix + ".trafficRoutes";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const RouteToLocation& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success =
            value.validate(msg, currentValuePath + ".trafficRoutes") && success;

        i++;
      }
    }
  }

  if (tempValiditiesIsSet()) {
    const std::vector<TemporalValidity>& value = m_TempValidities;
    const std::string currentValuePath = _pathPrefix + ".tempValidities";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const TemporalValidity& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".tempValidities") &&
                  success;

        i++;
      }
    }
  }

  if (validGeoZoneIdsIsSet()) {
    const std::vector<std::string>& value = m_ValidGeoZoneIds;
    const std::string currentValuePath    = _pathPrefix + ".validGeoZoneIds";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const std::string& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        i++;
      }
    }
  }

  return success;
}

bool TrafficInfluSubPatch::operator==(const TrafficInfluSubPatch& rhs) const {
  return

      ((!appReloIndIsSet() && !rhs.appReloIndIsSet()) ||
       (appReloIndIsSet() && rhs.appReloIndIsSet() &&
        isAppReloInd() == rhs.isAppReloInd())) &&

      ((!trafficFiltersIsSet() && !rhs.trafficFiltersIsSet()) ||
       (trafficFiltersIsSet() && rhs.trafficFiltersIsSet() &&
        getTrafficFilters() == rhs.getTrafficFilters())) &&

      ((!ethTrafficFiltersIsSet() && !rhs.ethTrafficFiltersIsSet()) ||
       (ethTrafficFiltersIsSet() && rhs.ethTrafficFiltersIsSet() &&
        getEthTrafficFilters() == rhs.getEthTrafficFilters())) &&

      ((!trafficRoutesIsSet() && !rhs.trafficRoutesIsSet()) ||
       (trafficRoutesIsSet() && rhs.trafficRoutesIsSet() &&
        getTrafficRoutes() == rhs.getTrafficRoutes())) &&

      ((!tfcCorrIndIsSet() && !rhs.tfcCorrIndIsSet()) ||
       (tfcCorrIndIsSet() && rhs.tfcCorrIndIsSet() &&
        isTfcCorrInd() == rhs.isTfcCorrInd())) &&

      ((!tempValiditiesIsSet() && !rhs.tempValiditiesIsSet()) ||
       (tempValiditiesIsSet() && rhs.tempValiditiesIsSet() &&
        getTempValidities() == rhs.getTempValidities())) &&

      ((!validGeoZoneIdsIsSet() && !rhs.validGeoZoneIdsIsSet()) ||
       (validGeoZoneIdsIsSet() && rhs.validGeoZoneIdsIsSet() &&
        getValidGeoZoneIds() == rhs.getValidGeoZoneIds())) &&

      ((!afAckIndIsSet() && !rhs.afAckIndIsSet()) ||
       (afAckIndIsSet() && rhs.afAckIndIsSet() &&
        isAfAckInd() == rhs.isAfAckInd())) &&

      ((!addrPreserIndIsSet() && !rhs.addrPreserIndIsSet()) ||
       (addrPreserIndIsSet() && rhs.addrPreserIndIsSet() &&
        isAddrPreserInd() == rhs.isAddrPreserInd()))

          ;
}

bool TrafficInfluSubPatch::operator!=(const TrafficInfluSubPatch& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const TrafficInfluSubPatch& o) {
  j = nlohmann::json();
  if (o.appReloIndIsSet()) j["appReloInd"] = o.m_AppReloInd;
  if (o.trafficFiltersIsSet() || !o.m_TrafficFilters.empty())
    j["trafficFilters"] = o.m_TrafficFilters;
  if (o.ethTrafficFiltersIsSet() || !o.m_EthTrafficFilters.empty())
    j["ethTrafficFilters"] = o.m_EthTrafficFilters;
  if (o.trafficRoutesIsSet() || !o.m_TrafficRoutes.empty())
    j["trafficRoutes"] = o.m_TrafficRoutes;
  if (o.tfcCorrIndIsSet()) j["tfcCorrInd"] = o.m_TfcCorrInd;
  if (o.tempValiditiesIsSet() || !o.m_TempValidities.empty())
    j["tempValidities"] = o.m_TempValidities;
  if (o.validGeoZoneIdsIsSet() || !o.m_ValidGeoZoneIds.empty())
    j["validGeoZoneIds"] = o.m_ValidGeoZoneIds;
  if (o.afAckIndIsSet()) j["afAckInd"] = o.m_AfAckInd;
  if (o.addrPreserIndIsSet()) j["addrPreserInd"] = o.m_AddrPreserInd;
}

void from_json(const nlohmann::json& j, TrafficInfluSubPatch& o) {
  if (j.find("appReloInd") != j.end()) {
    j.at("appReloInd").get_to(o.m_AppReloInd);
    o.m_AppReloIndIsSet = true;
  }
  if (j.find("trafficFilters") != j.end()) {
    j.at("trafficFilters").get_to(o.m_TrafficFilters);
    o.m_TrafficFiltersIsSet = true;
  }
  if (j.find("ethTrafficFilters") != j.end()) {
    j.at("ethTrafficFilters").get_to(o.m_EthTrafficFilters);
    o.m_EthTrafficFiltersIsSet = true;
  }
  if (j.find("trafficRoutes") != j.end()) {
    j.at("trafficRoutes").get_to(o.m_TrafficRoutes);
    o.m_TrafficRoutesIsSet = true;
  }
  if (j.find("tfcCorrInd") != j.end()) {
    j.at("tfcCorrInd").get_to(o.m_TfcCorrInd);
    o.m_TfcCorrIndIsSet = true;
  }
  if (j.find("tempValidities") != j.end()) {
    j.at("tempValidities").get_to(o.m_TempValidities);
    o.m_TempValiditiesIsSet = true;
  }
  if (j.find("validGeoZoneIds") != j.end()) {
    j.at("validGeoZoneIds").get_to(o.m_ValidGeoZoneIds);
    o.m_ValidGeoZoneIdsIsSet = true;
  }
  if (j.find("afAckInd") != j.end()) {
    j.at("afAckInd").get_to(o.m_AfAckInd);
    o.m_AfAckIndIsSet = true;
  }
  if (j.find("addrPreserInd") != j.end()) {
    j.at("addrPreserInd").get_to(o.m_AddrPreserInd);
    o.m_AddrPreserIndIsSet = true;
  }
}

bool TrafficInfluSubPatch::isAppReloInd() const {
  return m_AppReloInd;
}
void TrafficInfluSubPatch::setAppReloInd(bool const value) {
  m_AppReloInd      = value;
  m_AppReloIndIsSet = true;
}
bool TrafficInfluSubPatch::appReloIndIsSet() const {
  return m_AppReloIndIsSet;
}
void TrafficInfluSubPatch::unsetAppReloInd() {
  m_AppReloIndIsSet = false;
}
std::vector<FlowInfo> TrafficInfluSubPatch::getTrafficFilters() const {
  return m_TrafficFilters;
}
void TrafficInfluSubPatch::setTrafficFilters(
    std::vector<FlowInfo> const& value) {
  m_TrafficFilters      = value;
  m_TrafficFiltersIsSet = true;
}
bool TrafficInfluSubPatch::trafficFiltersIsSet() const {
  return m_TrafficFiltersIsSet;
}
void TrafficInfluSubPatch::unsetTrafficFilters() {
  m_TrafficFiltersIsSet = false;
}
std::vector<EthFlowDescription> TrafficInfluSubPatch::getEthTrafficFilters()
    const {
  return m_EthTrafficFilters;
}
void TrafficInfluSubPatch::setEthTrafficFilters(
    std::vector<EthFlowDescription> const& value) {
  m_EthTrafficFilters      = value;
  m_EthTrafficFiltersIsSet = true;
}
bool TrafficInfluSubPatch::ethTrafficFiltersIsSet() const {
  return m_EthTrafficFiltersIsSet;
}
void TrafficInfluSubPatch::unsetEthTrafficFilters() {
  m_EthTrafficFiltersIsSet = false;
}
std::vector<RouteToLocation> TrafficInfluSubPatch::getTrafficRoutes() const {
  return m_TrafficRoutes;
}
void TrafficInfluSubPatch::setTrafficRoutes(
    std::vector<RouteToLocation> const& value) {
  m_TrafficRoutes      = value;
  m_TrafficRoutesIsSet = true;
}
bool TrafficInfluSubPatch::trafficRoutesIsSet() const {
  return m_TrafficRoutesIsSet;
}
void TrafficInfluSubPatch::unsetTrafficRoutes() {
  m_TrafficRoutesIsSet = false;
}
bool TrafficInfluSubPatch::isTfcCorrInd() const {
  return m_TfcCorrInd;
}
void TrafficInfluSubPatch::setTfcCorrInd(bool const value) {
  m_TfcCorrInd      = value;
  m_TfcCorrIndIsSet = true;
}
bool TrafficInfluSubPatch::tfcCorrIndIsSet() const {
  return m_TfcCorrIndIsSet;
}
void TrafficInfluSubPatch::unsetTfcCorrInd() {
  m_TfcCorrIndIsSet = false;
}
std::vector<TemporalValidity> TrafficInfluSubPatch::getTempValidities() const {
  return m_TempValidities;
}
void TrafficInfluSubPatch::setTempValidities(
    std::vector<TemporalValidity> const& value) {
  m_TempValidities      = value;
  m_TempValiditiesIsSet = true;
}
bool TrafficInfluSubPatch::tempValiditiesIsSet() const {
  return m_TempValiditiesIsSet;
}
void TrafficInfluSubPatch::unsetTempValidities() {
  m_TempValiditiesIsSet = false;
}
std::vector<std::string> TrafficInfluSubPatch::getValidGeoZoneIds() const {
  return m_ValidGeoZoneIds;
}
void TrafficInfluSubPatch::setValidGeoZoneIds(
    std::vector<std::string> const& value) {
  m_ValidGeoZoneIds      = value;
  m_ValidGeoZoneIdsIsSet = true;
}
bool TrafficInfluSubPatch::validGeoZoneIdsIsSet() const {
  return m_ValidGeoZoneIdsIsSet;
}
void TrafficInfluSubPatch::unsetValidGeoZoneIds() {
  m_ValidGeoZoneIdsIsSet = false;
}
bool TrafficInfluSubPatch::isAfAckInd() const {
  return m_AfAckInd;
}
void TrafficInfluSubPatch::setAfAckInd(bool const value) {
  m_AfAckInd      = value;
  m_AfAckIndIsSet = true;
}
bool TrafficInfluSubPatch::afAckIndIsSet() const {
  return m_AfAckIndIsSet;
}
void TrafficInfluSubPatch::unsetAfAckInd() {
  m_AfAckIndIsSet = false;
}
bool TrafficInfluSubPatch::isAddrPreserInd() const {
  return m_AddrPreserInd;
}
void TrafficInfluSubPatch::setAddrPreserInd(bool const value) {
  m_AddrPreserInd      = value;
  m_AddrPreserIndIsSet = true;
}
bool TrafficInfluSubPatch::addrPreserIndIsSet() const {
  return m_AddrPreserIndIsSet;
}
void TrafficInfluSubPatch::unsetAddrPreserInd() {
  m_AddrPreserIndIsSet = false;
}

}  // namespace oai::nef::model
