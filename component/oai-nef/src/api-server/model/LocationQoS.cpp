/**
 * 3gpp-monitoring-event
 * API for Monitoring Event. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS,
 * CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.2.0-alpha.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "LocationQoS.h"

#include <sstream>

#include "Helpers.h"

namespace oai::nef::model {

LocationQoS::LocationQoS() {
  m_HAccuracy              = 0.0f;
  m_HAccuracyIsSet         = false;
  m_VAccuracy              = 0.0f;
  m_VAccuracyIsSet         = false;
  m_VerticalRequested      = false;
  m_VerticalRequestedIsSet = false;
  m_ResponseTimeIsSet      = false;
  m_LcsQosClassIsSet       = false;
}

void LocationQoS::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::nef::helpers::ValidationException(msg.str());
  }
}

bool LocationQoS::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool LocationQoS::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "LocationQoS" : pathPrefix;

  if (hAccuracyIsSet()) {
    const float& value                 = m_HAccuracy;
    const std::string currentValuePath = _pathPrefix + ".hAccuracy";

    if (value < static_cast<float>(0)) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  if (vAccuracyIsSet()) {
    const float& value                 = m_VAccuracy;
    const std::string currentValuePath = _pathPrefix + ".vAccuracy";

    if (value < static_cast<float>(0)) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 0;";
    }
  }

  return success;
}

bool LocationQoS::operator==(const LocationQoS& rhs) const {
  return

      ((!hAccuracyIsSet() && !rhs.hAccuracyIsSet()) ||
       (hAccuracyIsSet() && rhs.hAccuracyIsSet() &&
        getHAccuracy() == rhs.getHAccuracy())) &&

      ((!vAccuracyIsSet() && !rhs.vAccuracyIsSet()) ||
       (vAccuracyIsSet() && rhs.vAccuracyIsSet() &&
        getVAccuracy() == rhs.getVAccuracy())) &&

      ((!verticalRequestedIsSet() && !rhs.verticalRequestedIsSet()) ||
       (verticalRequestedIsSet() && rhs.verticalRequestedIsSet() &&
        isVerticalRequested() == rhs.isVerticalRequested())) &&

      ((!responseTimeIsSet() && !rhs.responseTimeIsSet()) ||
       (responseTimeIsSet() && rhs.responseTimeIsSet() &&
        getResponseTime() == rhs.getResponseTime())) &&

      ((!lcsQosClassIsSet() && !rhs.lcsQosClassIsSet()) ||
       (lcsQosClassIsSet() && rhs.lcsQosClassIsSet() &&
        getLcsQosClass() == rhs.getLcsQosClass()))

          ;
}

bool LocationQoS::operator!=(const LocationQoS& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const LocationQoS& o) {
  j = nlohmann::json();
  if (o.hAccuracyIsSet()) j["hAccuracy"] = o.m_HAccuracy;
  if (o.vAccuracyIsSet()) j["vAccuracy"] = o.m_VAccuracy;
  if (o.verticalRequestedIsSet())
    j["verticalRequested"] = o.m_VerticalRequested;
  if (o.responseTimeIsSet()) j["responseTime"] = o.m_ResponseTime;
  if (o.lcsQosClassIsSet()) j["lcsQosClass"] = o.m_LcsQosClass;
}

void from_json(const nlohmann::json& j, LocationQoS& o) {
  if (j.find("hAccuracy") != j.end()) {
    j.at("hAccuracy").get_to(o.m_HAccuracy);
    o.m_HAccuracyIsSet = true;
  }
  if (j.find("vAccuracy") != j.end()) {
    j.at("vAccuracy").get_to(o.m_VAccuracy);
    o.m_VAccuracyIsSet = true;
  }
  if (j.find("verticalRequested") != j.end()) {
    j.at("verticalRequested").get_to(o.m_VerticalRequested);
    o.m_VerticalRequestedIsSet = true;
  }
  if (j.find("responseTime") != j.end()) {
    j.at("responseTime").get_to(o.m_ResponseTime);
    o.m_ResponseTimeIsSet = true;
  }
  if (j.find("lcsQosClass") != j.end()) {
    j.at("lcsQosClass").get_to(o.m_LcsQosClass);
    o.m_LcsQosClassIsSet = true;
  }
}

float LocationQoS::getHAccuracy() const {
  return m_HAccuracy;
}
void LocationQoS::setHAccuracy(float const value) {
  m_HAccuracy      = value;
  m_HAccuracyIsSet = true;
}
bool LocationQoS::hAccuracyIsSet() const {
  return m_HAccuracyIsSet;
}
void LocationQoS::unsetHAccuracy() {
  m_HAccuracyIsSet = false;
}
float LocationQoS::getVAccuracy() const {
  return m_VAccuracy;
}
void LocationQoS::setVAccuracy(float const value) {
  m_VAccuracy      = value;
  m_VAccuracyIsSet = true;
}
bool LocationQoS::vAccuracyIsSet() const {
  return m_VAccuracyIsSet;
}
void LocationQoS::unsetVAccuracy() {
  m_VAccuracyIsSet = false;
}
bool LocationQoS::isVerticalRequested() const {
  return m_VerticalRequested;
}
void LocationQoS::setVerticalRequested(bool const value) {
  m_VerticalRequested      = value;
  m_VerticalRequestedIsSet = true;
}
bool LocationQoS::verticalRequestedIsSet() const {
  return m_VerticalRequestedIsSet;
}
void LocationQoS::unsetVerticalRequested() {
  m_VerticalRequestedIsSet = false;
}
ResponseTime LocationQoS::getResponseTime() const {
  return m_ResponseTime;
}
void LocationQoS::setResponseTime(ResponseTime const& value) {
  m_ResponseTime      = value;
  m_ResponseTimeIsSet = true;
}
bool LocationQoS::responseTimeIsSet() const {
  return m_ResponseTimeIsSet;
}
void LocationQoS::unsetResponseTime() {
  m_ResponseTimeIsSet = false;
}
LcsQosClass LocationQoS::getLcsQosClass() const {
  return m_LcsQosClass;
}
void LocationQoS::setLcsQosClass(LcsQosClass const& value) {
  m_LcsQosClass      = value;
  m_LcsQosClassIsSet = true;
}
bool LocationQoS::lcsQosClassIsSet() const {
  return m_LcsQosClassIsSet;
}
void LocationQoS::unsetLcsQosClass() {
  m_LcsQosClassIsSet = false;
}

}  // namespace oai::nef::model
